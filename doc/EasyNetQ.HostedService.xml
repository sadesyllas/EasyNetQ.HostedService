<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EasyNetQ.HostedService</name>
    </assembly>
    <members>
        <member name="T:EasyNetQ.HostedService.Abstractions.IAckException">
            <summary>
            When thrown from a consumer's handler, an ACK will be sent for the message to the RabbitMQ server.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.IBusProxy">
            <summary>
            A wrapper around an <see cref="T:EasyNetQ.IAdvancedBus"/> to bind it to an <see cref="P:EasyNetQ.HostedService.Abstractions.IBusProxy.Id"/>, thus giving it a
            name.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IBusProxy.Id">
            <summary>
            The <c>Id</c> of the configuration which names an instance of <see cref="T:EasyNetQ.IAdvancedBus"/>.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IBusProxy.Bus">
            <summary>
            An initialized <see cref="T:EasyNetQ.IAdvancedBus"/> instance.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.IIncomingMessageInterceptor">
             <summary>
             A message interceptor for incoming messages.
            
             Messages are intercepted before they reach the registered message handler.
            
             This mechanism can be used, eg, to read headers in incoming messages, in a transparent manner.
             </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.Abstractions.IIncomingMessageInterceptor.InterceptMessage``1(EasyNetQ.IMessage{``0},EasyNetQ.MessageReceivedInfo,System.Threading.CancellationToken)">
            <summary>
            Intercepts incoming messages before they reach the registered message handler.
            </summary>
            <param name="message"></param>
            <param name="messageReceivedInfo"></param>
            <param name="cancellationToken"></param>
            <typeparam name="T">
            The type of the received message.
            </typeparam>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.IIncomingMessageInterceptor`1">
            <inheritdoc cref="T:EasyNetQ.HostedService.Abstractions.IIncomingMessageInterceptor"/>
            <typeparam name="T">
            The subclass of <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/> for which the <see cref="T:EasyNetQ.HostedService.Abstractions.IIncomingMessageInterceptor`1"/>
            has being registered.
            </typeparam>
            <remarks>
            Type parameter <typeparamref name="T"/> can be used to differentiate between the various
            <see cref="T:EasyNetQ.HostedService.Abstractions.IIncomingMessageInterceptor`1"/> implementations that have been registered with dependency
            injection.
            </remarks>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.INackWithoutRequeueException">
            <summary>
            When thrown from a consumer's handler, a NACK will be sent for the message to the RabbitMQ server but the
            message will not be requeued.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.INackWithRequeueException">
            <summary>
            When thrown from a consumer's handler, a NACK will be sent for the message to the RabbitMQ server and the
            message will be requeued.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.IOutgoingMessageInterceptor">
             <summary>
             A message interceptor for outgoing messages.
            
             Messages are intercepted before they are sent to the RabbitMQ server.
            
             This mechanism can be used, eg, to inject headers to outgoing messages, in a transparent manner.
             </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.Abstractions.IOutgoingMessageInterceptor.InterceptMessage(System.Byte[],System.Type,System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <summary>
            Intercepts outgoing messages before they are sent to the RabbitMQ server.
            </summary>
            <param name="message"></param>
            <param name="type"></param>
            <param name="headers"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.IOutgoingMessageInterceptor`1">
            <inheritdoc cref="T:EasyNetQ.HostedService.Abstractions.IOutgoingMessageInterceptor"/>
            <typeparam name="T">
            The subclass of <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1"/> for which the <see cref="T:EasyNetQ.HostedService.Abstractions.IOutgoingMessageInterceptor`1"/>
            has being registered.
            </typeparam>
            <remarks>
            Type parameter <typeparamref name="T"/> can be used to differentiate between the various
            <see cref="T:EasyNetQ.HostedService.Abstractions.IOutgoingMessageInterceptor`1"/> implementations that have been registered with dependency
            injection.
            </remarks>
        </member>
        <member name="T:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig">
            <summary>
            The RabbitMQ related configuration section which contains all the necessary details for connecting to the
            RabbitMQ server.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.Id">
             <summary>
             Provides a way to name a RabbitMQ configuration in order to provide connection reusability.
            
             When the same <see cref="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.Id"/> is used for multiple consumers and/or producers, then all of them will use
             the same <see cref="T:EasyNetQ.IAdvancedBus"/> and thus, the same connection to the RabbitMQ server.
             </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.HostName">
            <summary>
            The RabbitMQ server hostname to connect to.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.Port">
            <summary>
            The RabbitMQ server port to connect to.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.VirtualHost">
            <summary>
            The RabbitMQ virtual host to use when connecting to the RabbitMQ server.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.UserName">
            <summary>
            The username with which to connect to RabbitMQ.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.Password">
            <summary>
            The password with which to connect to RabbitMQ.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.RequestedHeartbeat">
            <summary>
            The connection heartbeat in seconds.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.ReconnectionAttemptInterval">
            <summary>
            The interval with which to try to reconnect, once disconnected.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.PersistentMessages">
            <summary>
            For producers, whether to use persistent messages when sending a message.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.PublisherConfirms">
            <summary>
            For producers, whether to use RabbitMQ's Publisher Confirms feature.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.MessageDeliveryTimeout">
            <summary>
            For producers, it sets the timeout for publishing a message to the RabbitMQ server.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.PublisherLoopErrorBackOffMilliseconds">
             <summary>
             For the default producer implementation, the back off delay when an error occurs in the producer's loop.
            
             For details about the producer's queue, see <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1"/>.
             </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.Copy">
            <summary>
            Makes easy reusing a <see cref="T:EasyNetQ.HostedService.Models.RabbitMqConfig"/>.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1">
            <summary>
            This class implements the builder pattern for subclasses of <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            </summary>
            <typeparam name="T">
            The consumer or producer subclass of <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            </typeparam>
            <example>
            <code>
            // in the configuration callback of <see cref="M:Microsoft.Extensions.Hosting.IHostBuilder.ConfigureServices(System.Action{Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.IServiceCollection})"/>
            new RabbitMqServiceBuilder&lt;MyRabbitMqService&gt;()
                .WithRabbitMqConfig(rabbitMqConfig)
                .Build(services)
                .Add(services, typeof(MyInjectedRabbitMqServiceType), typeof(MyInjectedRabbitMqServiceOptionalExtraType))
            </code>
            </example>
        </member>
        <member name="P:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1.WithStronglyTypedMessages">
             <summary>
             Enable <see cref="T:EasyNetQ.HostedService.Internals.TypedMessageSerializationStrategy"/>.
            
             For consumers, it means that each incoming message is expected to have a valid <c>type</c> property,
             pointing to an available type in a <c>FULL_TYPE_NAME, ASSEMBLY_NAME</c> format, in order to deserialize the
             message into that type.
            
             For producers, it means that the message will be sent along with a valid <c>type</c> property in a
             <c>FULL_TYPE_NAME, ASSEMBLY_NAME</c> format.
             </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1.WithCorrelationIds">
            <summary>
            When set, producers will send a correlation id along with each message.
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1.WithRabbitMqConfig(EasyNetQ.HostedService.Abstractions.IRabbitMqConfig)">
            <summary>
            Sets the <see cref="T:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig"/> for the registered <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1.OnConnected(EasyNetQ.HostedService.OnConnectedCallback)">
            <summary>
            Adds a callback to run each time the <see cref="T:EasyNetQ.IAdvancedBus"/> is connected to the RabbitMQ server.
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1.OnConnectedOnce(EasyNetQ.HostedService.OnConnectedCallback)">
             <summary>
             Adds a callback to run each time the <see cref="T:EasyNetQ.IAdvancedBus"/> is connected to the RabbitMQ server.
            
             The callback is wrapped into a closure that makes sure that the callback is run only once.
             </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1.Build(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
             <summary>
             Builds a <see cref="T:Microsoft.Extensions.DependencyInjection.ServiceDescriptor"/>, describing a singleton <see cref="T:Microsoft.Extensions.Hosting.IHostedService"/>, to be used
             with dependency injection.
             </summary>
             <remarks>
             It reuses an existing <see cref="T:EasyNetQ.HostedService.Abstractions.IBusProxy"/> singleton, if one is found using the provided
             <see cref="P:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig.Id"/>.
            
             If not, a new <see cref="T:EasyNetQ.HostedService.Abstractions.IBusProxy"/> singleton is registered in the service factory wrapped by the
             <see cref="T:Microsoft.Extensions.DependencyInjection.ServiceDescriptor"/>.
             </remarks>
        </member>
        <member name="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilderExtensions">
            <summary>
            Extension methods for <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/>.
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilderExtensions.Add``1(System.Func{System.IServiceProvider,``0},Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type[])">
             <summary>
             Registers a subclass of <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/> to be used with dependency injection.
            
             It registers the <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/> both as <paramref name="type"/> and optionally, as
             <paramref name="extraTypes"/>.
             </summary>
             <typeparam name="T">
             The consumer or producer subclass of <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
             </typeparam>
             <param name="serviceFactory">
             The factory function that builds the <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
             </param>
             <param name="serviceCollection">
             The <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> with which to register the <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
             </param>
             <param name="type">
             The type with witch to register the <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/> in the
             <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/>.
             </param>
             <param name="extraTypes">
             Optional, extra types with witch to register the <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/> in the
             <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/>.
             </param>
        </member>
        <member name="T:EasyNetQ.HostedService.Internals.TypedMessageSerializationStrategy">
             <summary>
             An override for the default EasyNetQ implementation of <see cref="T:EasyNetQ.IMessageSerializationStrategy"/>.
            
             It uses a <see cref="T:EasyNetQ.ITypeNameSerializer"/> to deserialize the message's type from the RabbitMQ message's
             <c>type</c> property.
             </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.Internals.UnhandledHeaderTypeException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:EasyNetQ.HostedService.Internals.UnhandledHeaderTypeException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:EasyNetQ.HostedService.Internals.UnhandledHeaderTypeException.#ctor(System.String,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:EasyNetQ.HostedService.Internals.UnhandledHeaderTypeException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:EasyNetQ.HostedService.Internals.UnhandledHeaderTypeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:EasyNetQ.HostedService.Internals.UnhandledMessageTypeException">
            <summary>
            Thrown when a consumer's <see cref="T:EasyNetQ.IMessage`1"/> default handler for <see cref="T:System.Object"/> is run, since
            that means that no other consumer handler matched the message type.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Internals.UntypedMessageSerializationStrategy">
             <summary>
             An override for the default EasyNetQ implementation of <see cref="T:EasyNetQ.IMessageSerializationStrategy"/>.
            
             It omits checking for the RabbitMQ message's <c>type</c> property, thus handling all messages as having a type
             of <see cref="T:System.String"/>.
             </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Models.AckException">
            <summary>
            <inheritdoc cref="T:EasyNetQ.HostedService.Abstractions.IAckException"/>
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.Models.AckException.#ctor(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="message"/>
        </member>
        <member name="M:EasyNetQ.HostedService.Models.AckException.#ctor(System.Exception,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="message"/>
            <param name="innerException"/>
        </member>
        <member name="T:EasyNetQ.HostedService.Models.BusProxy">
            <summary>
            <inheritdoc cref="T:EasyNetQ.HostedService.Abstractions.IBusProxy"/>
            </summary>
            <remarks>
            This is the default <see cref="T:EasyNetQ.HostedService.Abstractions.IBusProxy"/> implementation and it offers lazy instantiation of the
            <see cref="T:EasyNetQ.IAdvancedBus"/> property.
            </remarks>
        </member>
        <member name="T:EasyNetQ.HostedService.Models.ConsumerConfig">
             <summary>
             The class that encapsulates the configuration of a consumer.
            
             It is expected to be provided by classes derived from <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/>.
             </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.ConsumerConfig.Queue">
            <summary>
            The <see cref="T:EasyNetQ.Topology.IQueue"/> object needed by a class derived from <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/>, which
            represents the queue that the consumer is to consumer from.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.ConsumerConfig.Priority">
            <summary>
            The consumer's priority.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.ConsumerConfig.IsExclusive">
            <summary>
            If true, the consumer is set to be the exclusive consumer of the provided <see cref="P:EasyNetQ.HostedService.Models.ConsumerConfig.Queue"/>.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.ConsumerConfig.PrefetchCount">
            <summary>
            The prefetch count that will be negotiated on the consumer's channel.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Models.NackWithoutRequeueException">
            <summary>
            <inheritdoc cref="T:EasyNetQ.HostedService.Abstractions.INackWithoutRequeueException"/>
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.Models.NackWithoutRequeueException.#ctor(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="message"/>
        </member>
        <member name="M:EasyNetQ.HostedService.Models.NackWithoutRequeueException.#ctor(System.Exception,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="message"/>
            <param name="innerException"/>
        </member>
        <member name="T:EasyNetQ.HostedService.Models.NackWithRequeueException">
            <summary>
            <inheritdoc cref="T:EasyNetQ.HostedService.Abstractions.INackWithRequeueException"/>
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.Models.NackWithRequeueException.#ctor(System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="message"/>
        </member>
        <member name="M:EasyNetQ.HostedService.Models.NackWithRequeueException.#ctor(System.Exception,System.String)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="message"/>
            <param name="innerException"/>
        </member>
        <member name="T:EasyNetQ.HostedService.Models.PublishResult">
            <summary>
            The result of calling <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.PublishAsync``1(System.String,System.String,``0,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.Object})"/>.
            </summary>
        </member>
        <member name="F:EasyNetQ.HostedService.Models.PublishResult.Published">
            <summary>
            The message was published successfully.
            </summary>
        </member>
        <member name="F:EasyNetQ.HostedService.Models.PublishResult.NotPublished">
            <summary>
            The message was not published successfully because an error occured.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.Models.RabbitMqConfig">
            <summary>
            <inheritdoc cref="T:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig"/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.Id">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.HostName">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.Port">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.VirtualHost">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.UserName">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.Password">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.RequestedHeartbeat">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.ReconnectionAttemptInterval">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.PersistentMessages">
            <summary>
            <inheritdoc/>
            </summary>
            <remarks>
            By default, it is set to <c>true</c>.
            </remarks>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.PublisherConfirms">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.MessageDeliveryTimeout">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.PublisherLoopErrorBackOffMilliseconds">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.Models.RabbitMqConfig.Copy">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.Models.RabbitMqConfig.Clone">
            <summary>
            <inheritdoc/>
            </summary>
            <returns/>
        </member>
        <member name="T:EasyNetQ.HostedService.RabbitMqConsumer`1">
             <summary>
             The subclasses of <c>RabbitMqConsumer&lt;T&gt;</c> are hosted services that can be registered through
             dependency injection.
            
             For a convenient way to inject such a consumer hosted service, see <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/>.
            
             Using <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/>, allows one to inject such a consumer as
             <c>RabbitMqConsumer&lt;T&gt;</c>.
             </summary>
             <typeparam name="T">
             The subclass of <c>RabbitMqConsumer&lt;T&gt;</c> that will be registered as a consumer through
             dependency injection.
             </typeparam>
             <remarks>
             Any required services can be injected through constructor parameters as with any other hosted service.
             </remarks>
             <example>
             <code><![CDATA[
             // An example of a consumer type.
            
              using System.Threading;
              using System.Threading.Tasks;
              using EasyNetQ.Consumer;
              using EasyNetQ.Events;
              using EasyNetQ.HostedService.Models;
              using EasyNetQ.Topology;
              using Microsoft.Extensions.Hosting;
              using Microsoft.Extensions.Logging;
            
             namespace EasyNetQ.HostedService.TestApp
             {
                 public struct EchoMessage
                 {
                     public string Text { get; set; }
                 }
            
                 public class MyInjectableRabbitMqConsumer : RabbitMqConsumer<MyInjectableRabbitMqConsumer>
                 {
                     // optional constructor with additional injected dependencies
                     public MyInjectableRabbitMqConsumer(IHostEnvironment env)
                     {
                         // do something with env
                     }
            
                     protected override void Initialize()
                     {
                         // use initialized members like Bus and RabbitMqConfig (eg, Bus.QueueDeclare(...))
                     }
            
                     protected override void RegisterMessageHandlers(IHandlerRegistration handlers)
                     {
                         handlers.Add((IMessageHandler<string>) HandleMessage);
                     }
            
                     protected override ConsumerConfig GetConsumerConfig(CancellationToken cancellationToken)
                     {
                         return new ConsumerConfig
                         {
                             Queue = new Queue("MyQueueName")
                         };
                     }
            
                     protected override void OnStartConsumingEvent(StartConsumingSucceededEvent @event)
                     {
                         // the consumer has successfully started to consume
                     }
            
                     protected override void OnStartConsumingEvent(StartConsumingFailedEvent @event)
                     {
                         // the consumer has failed to start consuming
                     }
            
                     private Task<AckStrategy> HandleMessage(IMessage<string> message, MessageReceivedInfo info,
                         CancellationToken token)
                     {
                         Logger.LogDebug($"Received untyped message: {message.Body}");
            
                         return Task.FromResult(AckStrategies.Ack);
                     }
                 }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqConsumer`1.StopAsync(System.Threading.CancellationToken)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqConsumer`1.GetConsumerConfig(System.Threading.CancellationToken)">
            <summary>
            This method must be provided by classes derived from <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/>, in order to provide
            the necessary <see cref="T:EasyNetQ.HostedService.Models.ConsumerConfig"/> to start consuming.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqConsumer`1.OnStartConsumingEvent(EasyNetQ.Events.StartConsumingSucceededEvent)">
            <summary>
            Registers an event handler for the <see cref="T:EasyNetQ.Events.StartConsumingSucceededEvent"/> event.
            </summary>
            <param name="event"></param>
            <remarks>
            This method can be overriden by classes derived from <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/>.
            </remarks>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqConsumer`1.OnStartConsumingEvent(EasyNetQ.Events.StartConsumingFailedEvent)">
            <summary>
            Registers an event handler for the <see cref="T:EasyNetQ.Events.StartConsumingFailedEvent"/> event.
            </summary>
            <param name="event"></param>
            <remarks>
            This method can be overriden by classes derived from <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/>.
            </remarks>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqConsumer`1.InitializeConsumer(System.Threading.CancellationToken)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="cancellationToken"/>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqConsumer`1.InitializeProducer(System.Threading.CancellationToken)">
             <summary>
             Expected to be overriden by producers.
            
             The default implementation for consumers throws <see cref="T:System.NotSupportedException"/>.
             </summary>
             <param name="cancellationToken"/>
             <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="T:EasyNetQ.HostedService.RabbitMqProducer`1">
             <summary>
             The subclasses of <c>RabbitMqProducer&lt;T&gt;</c> are hosted services that can be registered through
             dependency injection.
            
             For a convenient way to inject such a producer hosted service, see <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/>.
            
             Using <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/>, allows one to inject such a producer as
             <c>RabbitMqProducer&lt;T&gt;</c>.
             </summary>
             <typeparam name="T">
             The subclass of <c>RabbitMqProducer&lt;T&gt;</c> that will be registered as a producer through
             dependency injection.
             </typeparam>
             <remarks>
             Any required services can be injected through constructor parameters as with any other hosted service.
            
             The default <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1"/> implementation uses a <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> of
             <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1.Message"/> as the message queue and a separate <see cref="T:System.Threading.Tasks.Task"/> to dequeue
             messages and send them to the RabbitMQ server.
             </remarks>
             /// <example>
             <code><![CDATA[
             // An example of a producer type.
            
             using Microsoft.Extensions.Hosting;
            
             namespace EasyNetQ.HostedService.TestApp
             {
                 public class MyInjectableRabbitMqProducer : RabbitMqProducer<MyInjectableRabbitMqProducer>
                 {
                     // optional constructor with additional injected dependencies
                     public MyInjectableRabbitMqProducer(IHostEnvironment env)
                     {
                         // do something with env
                     }
            
                     protected override void Initialize()
                     {
                         // use initialized members like Bus and RabbitMqConfig
                     }
                 }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.InitializeProducer(System.Threading.CancellationToken)">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="cancellationToken"/>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.PublishAsync``1(System.String,System.String,``0,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Enqueues a message of type <c>TMessage</c> for publishing after turning it into a <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1.Message"/>.
            </summary>
            <param name="exchange"/>
            <param name="routingKey"/>
            <param name="payload"/>
            <param name="mandatory"/>
            <param name="headers"></param>
            <typeparam name="TMessage"/>
            <exception cref="T:System.ArgumentException"></exception>
            <returns>
            It returns a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> which can be awaited until the message is
            actually sent to the RabbitMQ server.
            </returns>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.OnInitialization(System.Threading.CancellationToken)">
            <summary>
            Called by <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.InitializeProducer(System.Threading.CancellationToken)"/> before calling <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.StartProducerLoop(System.Threading.CancellationToken)"/>.
            </summary>
            <param name="cancellationToken">
            The cancellation token with which <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.InitializeProducer(System.Threading.CancellationToken)"/> has been called.
            </param>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.EnqueueMessage(EasyNetQ.HostedService.RabbitMqProducer{`0}.Message)">
             <summary>
             Enqueues a message to be sent by the producer.
            
             This method is called by <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.PublishAsync``1(System.String,System.String,``0,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.Object})"/>.
             </summary>
             <remarks>
             One can override this method to provide an alternative mechanism for enqueuing the messages.
            
             If this method is overriden, <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.DequeueMessage(EasyNetQ.HostedService.RabbitMqProducer{`0}.Message@)"/> should also be overriden.
             </remarks>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.DequeueMessage(EasyNetQ.HostedService.RabbitMqProducer{`0}.Message@)">
             <summary>
             Dequeues a message to be sent by the producer.
            
             This method is called by by the producer's message loop thread.
             </summary>
             <param name="message">
             The message to enqueue.
             </param>
             <returns>
             Returns <c>True</c> if a message was successfully dequeued, <c>False</c> otherwise.
             </returns>
             <remarks>
             One can override this method to provide an alternative mechanism for dequeuing the messages.
            
             If this method is overriden, <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.EnqueueMessage(EasyNetQ.HostedService.RabbitMqProducer{`0}.Message)"/> should also be overriden.
             </remarks>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.OnCancellation">
            <summary>
            This method is called by the producer's message loop thread, which started by
            <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.StartProducerLoop(System.Threading.CancellationToken)"/>, after cancellation has been requested on the
            <see cref="T:System.Threading.CancellationToken"/> with which <see cref="M:EasyNetQ.HostedService.RabbitMqProducer`1.InitializeProducer(System.Threading.CancellationToken)"/> has been called.
            </summary>
        </member>
        <member name="T:EasyNetQ.HostedService.RabbitMqProducer`1.Message">
            <summary>
            The message type that is actually enqueued in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.RegisterMessageHandlers(EasyNetQ.Consumer.IHandlerRegistration)">
             <summary>
             Expected to be overriden by consumers.
            
             The default implementation for producers throws a <see cref="T:System.NotImplementedException"/>.
             </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqProducer`1.InitializeConsumer(System.Threading.CancellationToken)">
             <summary>
             Expected to be overriden by consumers.
            
             The default implementation for producers throws <see cref="T:System.NotSupportedException"/>.
             </summary>
             <param name="cancellationToken"/>
             <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="T:EasyNetQ.HostedService.OnConnectedCallback">
            <summary>
            The callback type for callbacks that must run when a new connection is established to the RabbitMQ server.
            </summary>
            <param name="b"/>
            <param name="c"/>
            <param name="t"/>
            <param name="logger"/>
        </member>
        <member name="T:EasyNetQ.HostedService.RabbitMqService`1">
             <summary>
             A hosted service that accepts an EasyNetQ <see cref="T:EasyNetQ.IAdvancedBus"/> and uses it to either set up a consumer or
             a producer, given the configuration with which it has been created.
             </summary>
             <typeparam name="T">
             The subclass of <c>RabbitMqService&lt;T&gt;</c> that will be registered as either a consumer or a producer
             through dependency injection.
             </typeparam>
             <remarks>
             The purpose of this class is to gather the common concerns of handling an <see cref="T:EasyNetQ.IAdvancedBus"/> into a
             central place.
            
             There are two provided, abstract derived classes, <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/> and
             <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1"/>.
            
             The types that are to be registered with dependency injection, as consumers or producers, should derive one
             of these classes and potentially override the base class's functionality, as required.
            
             Any required services can be injected through constructor parameters, in the derived class,
             as with any other hosted service.
            
             For details and examples of the provided consumer and producer subclasses, please,
             see <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/> and <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1"/>.
             </remarks>
        </member>
        <member name="P:EasyNetQ.HostedService.RabbitMqService`1.Bus">
            <summary>
            The initialized <see cref="T:EasyNetQ.IAdvancedBus"/> that is exposed to subclasses of
            <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.RabbitMqService`1.RabbitMqConfig">
            <summary>
            The populated <see cref="T:EasyNetQ.HostedService.Abstractions.IRabbitMqConfig"/> that is exposed to subclasses of
            <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            </summary>
        </member>
        <member name="P:EasyNetQ.HostedService.RabbitMqService`1.Logger">
            <summary>
            The initialized <see cref="T:Microsoft.Extensions.Logging.ILogger`1"/> that is exposed to subclasses of <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            </summary>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.Create``1(System.Boolean,EasyNetQ.HostedService.Abstractions.IBusProxy,EasyNetQ.HostedService.Abstractions.IRabbitMqConfig,System.Collections.Generic.List{EasyNetQ.HostedService.OnConnectedCallback},System.IServiceProvider)">
             <summary>
             This static method is used by <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/> to construct a singleton hosted service
             for a consumer of a producer.
            
             Its purpose is to instantiate the <c>TDerived</c>, passing in the <see cref="T:System.IServiceProvider"/> argument.
            
             The services that can be injected this way are the ones that have been registered up to the call site of
             <see cref="M:EasyNetQ.HostedService.RabbitMqService`1.Create``1(System.Boolean,EasyNetQ.HostedService.Abstractions.IBusProxy,EasyNetQ.HostedService.Abstractions.IRabbitMqConfig,System.Collections.Generic.List{EasyNetQ.HostedService.OnConnectedCallback},System.IServiceProvider)"/>.
             </summary>
             <param name="isConsumer"/>
             <param name="busProxy"/>
             <param name="rmqConfig"/>
             <param name="onConnected"/>
             <param name="serviceProvider"/>
             <typeparam name="TDerived">
             The type of the consumer or producer that is being instantiated. It must match type parameter <c>T</c> of
             type <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
             </typeparam>
             <returns>
             An instantiated <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/> which should be used to register a consumer or
             producer as a singleton hosted service.
             </returns>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.CreateLazyBus(EasyNetQ.HostedService.Abstractions.IRabbitMqConfig,EasyNetQ.HostedService.Internals.MessageSerializationStrategy,System.Boolean,EasyNetQ.HostedService.Internals.HeaderTypeSerializationConfiguration,System.IServiceProvider)">
             <summary>
             This static method is used by <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/> to construct a singleton hosted
             service for a consumer of a producer.
            
             Its purpose is to be used with <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/> so as to allow reuse of
             <see cref="T:EasyNetQ.IAdvancedBus"/> singletons
            
             This is done in order to enable the use of the same or different connections to the RabbitMQ server, on
             demand.
            
             For more information about how <see cref="T:EasyNetQ.IAdvancedBus"/> instances can be reused, see
             <see cref="T:EasyNetQ.HostedService.DependencyInjection.RabbitMqServiceBuilder`1"/>.
             </summary>
             <param name="rmqConfig"/>
             <param name="messageSerializationStrategy"/>
             <param name="useCorrelationIds"/>
             <param name="serviceProvider"/>
             <returns/>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.StartAsync(System.Threading.CancellationToken)">
             <summary>
             Starts the hosted service and initializes the consumer or producer by either setting up the consumption of
             messages or by starting the producer's message queueing functionality.
            
             For details on the default implementations of consumers and producers, see <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/>
             and <see cref="T:EasyNetQ.HostedService.RabbitMqProducer`1"/>.
             </summary>
             <param name="cancellationToken"/>
             <returns/>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.StopAsync(System.Threading.CancellationToken)">
            <summary>
            Stops the hosted service by first disposing of any <c>IDisposable</c> instances that are created during
            service startup.
            </summary>
            <param name="cancellationToken"/>
            <returns/>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.RegisterMessageHandlers(EasyNetQ.Consumer.IHandlerRegistration)">
            <summary>
            This method must be provided by classes derived from <see cref="T:EasyNetQ.HostedService.RabbitMqConsumer`1"/>, in order to provide
            a message handler per expected message type.
            </summary>
            <param name="handlers"></param>
            <remarks>
            When the <see cref="T:EasyNetQ.HostedService.Internals.UntypedMessageSerializationStrategy"/> is used, then it only makes sense to provide a
            handler for the <see cref="T:System.String"/> type.
            </remarks>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.Initialize">
            <summary>
            This virtual function is called right after the instantiation of the subclass of
            <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            </summary>
            <remarks>
            Overriding this function allows the subclass of <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/> to access fields that are
            initialized after the construction of the instance, eg, <see cref="T:EasyNetQ.HostedService.RabbitMqService`1"/>.
            <see cref="P:EasyNetQ.HostedService.RabbitMqService`1.RabbitMqConfig"/>.
            </remarks>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.InitializeConsumer(System.Threading.CancellationToken)">
             <summary>
             This abstract function must be implemented by a subclass in order to initialize a consumer.
            
             This is not called for producers and it's declared as abstract only to enforce its implementation by
             consumers.
             </summary>
             <param name="cancellationToken"/>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.InitializeProducer(System.Threading.CancellationToken)">
             <summary>
             This abstract function must be implemented by a subclass in order to initialize a producer.
            
             This is not called for consumers and it's declared as abstract only to enforce its implementation by
             producers.
             </summary>
             <param name="cancellationToken"/>
        </member>
        <member name="M:EasyNetQ.HostedService.RabbitMqService`1.AddDisposable(System.IDisposable)">
            <summary>
            Adds a disposable into a common list of disposables in order to dispose of it on service termination.
            </summary>
            <param name="disposable"/>
        </member>
    </members>
</doc>
